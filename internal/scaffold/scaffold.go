package scaffold

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"micromanager/internal/config"
	"micromanager/internal/lang"
)

// InitOptions customizes repository initialization.
type InitOptions struct {
	Lang string
}

// NewServiceOptions configures service scaffolding.
type NewServiceOptions struct {
	Empty    bool
	Defaults config.Defaults
}

// InitRepo creates .mm structure, services directory, build directory, and defaults.
func InitRepo(ctx context.Context, root string, opts InitOptions) (config.Defaults, error) {
	_ = ctx
	defaults := config.DefaultDefaults()
	if opts.Lang != "" {
		defaults.Lang = opts.Lang
	}

	requiredDirs := []string{
		filepath.Join(root, ".mm"),
		filepath.Join(root, ".mm", "instructions"),
		filepath.Join(root, "services"),
		filepath.Join(root, "build"),
	}
	for _, dir := range requiredDirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return config.Defaults{}, err
		}
	}

	if err := config.SaveDefaults(root, defaults); err != nil {
		return config.Defaults{}, err
	}

	if err := ensureBuildIgnored(root); err != nil {
		return config.Defaults{}, err
	}
	return defaults, nil
}

// NewService scaffolds a service directory according to options and defaults.
func NewService(root, name string, opts NewServiceOptions) (config.ServiceConfig, error) {
	servicePath := filepath.Join(root, "services", name)
	if err := os.MkdirAll(servicePath, 0o755); err != nil {
		return config.ServiceConfig{}, err
	}

	svcCfg := config.ServiceConfig{}

	if opts.Empty {
		svcCfg.General.Lang = opts.Defaults.Lang
		svcCfg.General.External = true
	} else {
		svcCfg.General.Lang = opts.Defaults.Lang
	}

	// Persist config before creating files, so downstream logic can read it if needed.
	if err := config.SaveServiceConfig(root, name, svcCfg); err != nil {
		return config.ServiceConfig{}, err
	}

	if err := scaffoldServiceFiles(root, name, svcCfg, opts); err != nil {
		return config.ServiceConfig{}, err
	}

	if err := addDocInstruction(root, name); err != nil {
		return config.ServiceConfig{}, err
	}

	return svcCfg, nil
}

func scaffoldServiceFiles(root, name string, cfg config.ServiceConfig, opts NewServiceOptions) error {
	servicePath := filepath.Join(root, "services", name)

	// Attempt to use a language pack for this service language if available
	if !opts.Empty {
		if p, err := lang.FindByLang(root, cfg.General.Lang); err != nil {
			return err
		} else if p != nil {
			if err := lang.ApplyService(root, *p, name); err != nil {
				return err
			}
			// Pack applied successfully; do not run default scaffolding
			return nil
		}
	}

	if opts.Empty {
		if err := writeFile(filepath.Join(servicePath, "Dockerfile"), defaultDockerfile(cfg.General.Lang)); err != nil {
			return err
		}
		if err := writeFile(filepath.Join(servicePath, "README.md"), serviceReadme(name)); err != nil {
			return err
		}
		return nil
	}

	// No pack found - service directory already created, just add README
	return writeFile(filepath.Join(servicePath, "README.md"), serviceReadme(name))
}

func serviceReadme(name string) string {
	return fmt.Sprintf("# %s\n\nService scaffold generated by mm.\n", name)
}

func writeFile(path, content string) error {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return err
	}
	return os.WriteFile(path, []byte(content), 0o644)
}

func defaultDockerfile(lang string) string {
	return fmt.Sprintf("# Dockerfile for %s service\nFROM alpine\nCMD [\"echo\", \"stub\"]\n", lang)
}

func addDocInstruction(root, serviceName string) error {
	instructionsDir := filepath.Join(root, ".mm", "instructions")
	if err := os.MkdirAll(instructionsDir, 0o755); err != nil {
		return err
	}
	stamp := time.Now().UTC().Format("20060102T150405")
	file := filepath.Join(instructionsDir, fmt.Sprintf("%s.md", stamp))
	body := fmt.Sprintf(`# Update Instructions - %s

## Service: %s

Please update README.md and related docs for the new service. After completing, delete this file.
`, stamp, serviceName)
	return os.WriteFile(file, []byte(body), 0o644)
}

func ensureBuildIgnored(root string) error {
	path := filepath.Join(root, ".gitignore")
	content, err := os.ReadFile(path)
	if err != nil && !os.IsNotExist(err) {
		return err
	}
	if strings.Contains(string(content), "build/") {
		return nil
	}
	updated := string(content)
	if len(updated) > 0 && !strings.HasSuffix(updated, "\n") {
		updated += "\n"
	}
	updated += "build/\n"
	return os.WriteFile(path, []byte(updated), 0o644)
}
